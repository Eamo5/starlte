#!/sbin/sh
#

ZIPFILE=$3
OUTFD=$2

lversion=4.9.132
kversion=0.99.25
build=1
kname=APGK
tagline='A pretty good kernel.'
version_str="$kname $lversion-$kversion-$build"
scr_wdth=50

# Detect real $OUTFD
#
readlink /proc/$$/fd/$OUTFD 2>/dev/null | grep /tmp >/dev/null
if [ $? -eq 0 ]; then
  OUTFD=0
  for FD in `ls /proc/$$/fd` ; do
    readlink /proc/$$/fd/$FD 2>/dev/null | grep pipe >/dev/null
    if [ $? -eq 0 ]; then
      ps | grep " 3 $FD " | grep -v grep >/dev/null
      if [ $? -eq 0 ]; then
	OUTFD=$FD
	break
      fi
    fi
  done
fi

ui_print() {
  echo -ne "ui_print $1\n" >> /proc/self/fd/$OUTFD
  echo -ne "ui_print\n" >> /proc/self/fd/$OUTFD
}

print_full_bar() {
  ui_print "$(printf '%*s\n' $scr_wdth | tr ' ' '=')"
}

print_justified() {
  str="$1"
  str_len=${#str}
  padding_len=$(( ($scr_wdth - $str_len - 2) / 2))
  ljust="$(printf '%*s' $padding_len)"
  rjust="$(printf '%*s' $(($padding_len + $str_len % 2)))"

  ui_print "=$ljust$str$rjust="
}

resolve_link() {
  if [ -z "$1" ] || [ ! -e $1 ] ; then return 1 ; fi
  local VAR=$1
  while [ -L $VAR ]; do
    VAR=$(readlink $VAR)
  done
  echo $VAR
}

unzip_file() {
  unzip -l "$ZIPFILE" | grep "$1" >/dev/null || return 1
  unzip -p "$ZIPFILE" $1 > $2
  return $?
}

ui_print " "
print_full_bar
print_justified "$version_str"
print_justified "$tagline"
print_full_bar
ui_print " "

bl=$( getprop ro.boot.bootloader )

# Firmware version starts at either 8th or 9th character, depending on length
# of bootloader string (12 or 13).
#
fw=${bl:$((${#bl} - 4)):4}

# Device is either 4 or 5 characters long, depending on length of bootloader
# string.
#
device=${bl:0:$((${#bl} - 8))}

model=${device:0:4}
suffix=${device:4}

# BusyBox shell sucks.
#
#if [[ $device != G96[05][FN] ]]; then
if ! ( [ $model = G960 ] || [ $model = G965 ] &&
       [ $suffix = F ]   || [ $suffix = N ] ); then
  ui_print " - Unsupported device detected. Installation aborted."
  ui_print " "
  exit 1
fi

ui_print " - Detected a $device device on $fw firmware."

[ $suffix = N ] &&
  ui_print " - NOTE: '$suffix' device support is experimental."

BOOT=$(resolve_link $(find /dev/block/platform -type l -iname boot))

if [ -z "$BOOT" ]; then
  ui_print " - No boot partition found. Installation aborted."
  ui_print " "
  exit 1
fi

# Read kernel choice from archive name, if applicable.
#
ZIPNAME=${ZIPFILE##*/}
[ $ZIPNAME != ${ZIPNAME/_underclock//} ] && UNDERCLOCK=true
[ $ZIPNAME != ${ZIPNAME/_overclock//} ] && OVERCLOCK=true

# Otherwise, check for dotfiles to determine kernel choice.
#
[ -f /external_sd/.underclock ] && UNDERCLOCK=true
[ -f /external_sd/.overclock ] && OVERCLOCK=true

# Now get to work.
#
for i in boot-$kname-$lversion-$kversion-$build-g965.img \
	 boot-$kname-$lversion-$kversion-oc-$build-g965.img.bsdiff \
	 boot-$kname-$lversion-$kversion-uc-$build-g965.img.bsdiff \
	 boot-$kname-$lversion-$kversion-$build-g960.img.bsdiff \
	 boot-$kname-$lversion-$kversion-oc-$build-g960.img.bsdiff \
	 boot-$kname-$lversion-$kversion-uc-$build-g960.img.bsdiff \
	 bspatch; do
  unzip_file $i /tmp/$i
done

bspatch=/tmp/bspatch
chmod 755 $bspatch

image=standard
variant=""
src_img=/tmp/boot-$kname-$lversion-$kversion-$build-g965.img
g960_img=/tmp/boot-$kname-$lversion-$kversion-$build-g965.img

if [ "$OVERCLOCK" = true ]; then
  image=overclock
  variant=-oc
elif [ "$UNDERCLOCK" = true ]; then
  image=underclock
  variant=-uc
fi

lmodel=$( echo $model | tr '[A-Z]' '[a-z]' )
dst_img=/tmp/boot-$kname-$lversion-$kversion$variant-$build-$lmodel.img

if [ -f $dst_img.bsdiff ]; then
  ui_print " - Constructing $image kernel for $device..."

  if [ $model = G960 ] && [ -n "$variant" ]; then
    # First produce the standard G960F image, because the oc and uc deltas
    # are based on that.
    #
    $bspatch $src_img $g960_img $g960_img.bsdiff
    src_img=$g960_img
  fi

  [ -f $dst_img ] || $bspatch $src_img $dst_img $dst_img.bsdiff
fi

ui_print " - Flashing $image boot image onto $device..."
[ -n "$debug" ] && ui_print " - dd if=$dst_img of=$BOOT"

/sbin/dd if=$dst_img of=$BOOT 

ui_print " - Installation completed."

# Read desire to install Magisk from archive name, if applicable.
#
[ $ZIPNAME != ${ZIPNAME/_magisk//} ] && MAGISK=true

# Check for dotfile existence and install Magisk if present.
#
int=/sdcard/Download	# The standard download location on internal SD card.
ext=/external_sd	# The external SD card, if present.

# If .magisk exists at none of these locations and the APGK zip file doesn't
# contain _magisk in the name, we are finished.
#
if [ ! -f $int/.magisk ] && [ ! -f $ext/.magisk ] && [ -z "$MAGISK" ]; then
  ui_print " - You may now root the device at your discretion."
  ui_print " "

  exit 0
fi

# Find the most recent build of Magisk from the various locations.
#
# The order of precedence is:
#
# 1. Files with an explicit version in their name, e.g kantjer and ianmacd
#    builds.
# 2. Unversioned files that indicate a release build with their name, e.g.
#    official Canary channel release builds.
# 3. Unversioned files that indicate a debug build with their name, e.g.
#    official Canary channel debug builds.
# 4. Unversioned files matching the pattern [Mm]agisk.zip, e.g. files
#    extracted from ROMs, etc.
#
# Lexical sort order is used for category 1. The timestamp of the file is used
# for all others. If no files are found, we cannot proceed.
#
magisk=$( { ls -r $int/Magisk-v* $ext/Magisk/Magisk-v* 2>/dev/null;
	    ls -t $int/magisk-release.zip
		  $ext/Magisk/magisk-release.zip 2>/dev/null;
	    ls -t $int/magisk-debug.zip
		  $ext/Magisk/magisk-debug.zip 2>/dev/null;
	    ls -t $int/[Mm]agisk.zip
	    $ext/Magisk/[Mm]agisk.zip 2>/dev/null; } | head -n 1 )
if [ ! -f "$magisk" ]; then
  ui_print " - No Magisk zip file found."
  ui_print " "

  exit 1
fi

ui_print " - Installing ${magisk##*/}..."
ui_print " "

tmp=/tmp/magisk
mkdir $tmp
unzip -d $tmp $magisk META-INF/com/google/android/\* 
exec /sbin/sh $tmp/META-INF/com/google/android/update-binary dummy $OUTFD $magisk
